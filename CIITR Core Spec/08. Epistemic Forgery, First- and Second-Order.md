## 08. Epistemic Forgery, First- and Second-Order

This section defines “forgery” as a kernel threat model class. The purpose is ontological and procedural. CIITR is a boundary apparatus that relies on instrumentable signatures, therefore it is structurally exposed to imitation. Forgery is the name for that exposure when imitation produces apparent admissible signatures without the kernel conditions being instantiated. The section fixes forgery as a disqualifier family that couples directly to admissibility of $\Phi_i$, $R_g$, and therefore $C_s$.

Formally, forgery is represented as a protocol-bound disqualification predicate:

$$
\mathrm{Forgery}_\Pi(S) \in \{0,1,\varnothing\}
$$

with the binding consequence:

$$
\mathrm{Forgery}_\Pi(S)=1 \;\Longrightarrow\; C_s(S \mid \Pi,\mathcal{O}) \neq 1
$$

The kernel does not require that forgery be detected in all possible forms. It requires that any CIITR-conformant evaluation regime treats forgery as a primary threat class, and incorporates explicit controls whose failure invalidates positive claims.

### 8.1 First-order forgery, signature imitation at the measurement level

First-order forgery is the condition in which a system produces outputs that satisfy the surface criteria of an admissible signature, while the underlying kernel condition that the signature is intended to witness is not instantiated. It is forgery at the level of measurement outputs.

First-order forgery is therefore defined as a mismatch between signature conformance and kernel instantiation. Let $\sigma_\Pi(S)$ denote a protocol-defined signature predicate over observables, intended to witness a target kernel condition $\theta \in \{\Phi_i,R_g\}$. First-order forgery occurs when the signature predicate is satisfied but the kernel instantiation is not admissible.

$$
\mathrm{Forgery}^{(1)}_\Pi(S,\theta)
\;:\Longleftrightarrow\;
\sigma_\Pi(S,\theta)=1 \,\wedge\, \neg \mathrm{Adm}_\Pi(\theta,S)
$$

This definition binds the essential structure. It ensures that forgery is not defined as “deception intent,” but as *signature-level conformance without kernel-level admissibility*. This is critical for CIITR, since CIITR is not a psychological theory of intention, it is a classification regime under evidence constraints.

Kernel consequences follow immediately.

- Any signature that can be satisfied by superficial conformance alone is, by definition, forgeable.
- Therefore, admissibility rules must be paired with disqualifiers and negative controls that attempt to separate true instantiation from signature mimicry.

### 8.2 Second-order forgery, instrument and evaluation imitation

Second-order forgery is not forgery of the output signature alone. It is forgery of the *evaluation regime*. The system produces behavior that passes the protocol as administered, by exploiting regularities in the measurement process, audit process, or threshold procedure, without thereby instantiating the kernel property the evaluation intends to certify.

Second-order forgery is therefore defined as protocol gaming, meaning the evaluation regime becomes part of the system’s effective input, and the system’s behavior is tuned to the regime rather than to the kernel condition.

Let $\Pi$ denote the evaluation protocol and let $\Pi^\star$ denote the effective protocol as internalized by the system’s interaction with the evaluation constraints. Second-order forgery occurs when protocol sensitivity is such that passing is contingent on the specific evaluation scaffolding, and does not generalize across admissibility-preserving perturbations of the protocol.

Kernel form:

$$
\mathrm{Forgery}^{(2)}_\Pi(S)
\;:\Longleftrightarrow\;
\exists \Delta\Pi \in \mathcal{P}_\Pi,\;
\Big(\mathrm{Pass}(S,\Pi)=1 \,\wedge\, \mathrm{Pass}(S,\Pi+\Delta\Pi)=0\Big)
$$

Here $\mathcal{P}_\Pi$ denotes the set of admissibility-preserving protocol perturbations, a kernel placeholder for the class of variations that do not change the semantic target, but change the surface structure of the evaluation in ways that should not matter if the kernel condition is truly instantiated. The kernel does not enumerate $\mathcal{P}_\Pi$ here. It binds the requirement that such a class exists and is explicitly declared in any certification-grade implementation.

Second-order forgery is thus a structural threat: even if first-order signatures appear admissible, the evaluation regime itself may be the source of the appearance.

### 8.3 Adversarial robustness as a normative requirement

Because CIITR’s positive classifications are contingent on instrumentable signatures, and because those signatures are forgeable, CIITR imposes adversarial robustness as a normative requirement for admissibility. Robustness is not defined as maximal security. It is defined as the property that the claim survives an explicit class of forgery oriented negative controls.

Let $\mathrm{Robust}_\Pi(S)$ denote that the evaluation regime includes and passes the required forgery controls. Then:

$$
C_s(S \mid \Pi,\mathcal{O}) = 1
\;\Longrightarrow\;
\mathrm{Robust}_\Pi(S)
$$

The robustness requirement entails the following kernel commitments.

1. **Forgery control inclusion:** the protocol SHALL declare forgery oriented negative controls that explicitly attempt to elicit first-order and second-order forgery patterns.
2. **Disqualification authority:** any triggered forgery indicator SHALL have disqualifying force over axis admissibility and therefore over $C_s$.
3. **Audit trail binding:** the protocol SHALL retain sufficient metadata to support post hoc verification that forgery controls were executed as declared, and that their results were not selectively interpreted.
4. **Non-retroactive immunity:** the protocol SHALL not permit retrospective reinterpretation of forgery indicators as non-disqualifying without an explicit revision of $\Pi$ and explicit restatement of the claim under a new protocol version.

These requirements are kernel normative constraints. They do not prescribe specific adversarial techniques. They prescribe that the evaluation logic must assume adversarial pressure as a normal condition of certification-grade claims.

### 8.4 Snapshot-based certification cannot close second-order threat

Snapshot-based certification is structurally incompatible with CIITR’s forgery model, particularly the second-order class. A snapshot evaluation, by definition, restricts temporal structure and restricts the ability to execute admissibility-preserving perturbations of the evaluation regime. This creates a structural blind spot.

The kernel logic is as follows.

1. Second-order forgery is defined by protocol dependence under admissibility-preserving variations.
2. Snapshot regimes typically cannot express the temporal and procedural degrees of freedom required to instantiate such variations as part of the evidence basis.
3. Therefore snapshot regimes cannot, by construction, close the second-order threat model.

In kernel form:

$$
\mathrm{SnapshotOnly}(\Pi)
\;\Longrightarrow\;
\neg \mathrm{Decidable}_\Pi\!\big(\mathrm{Forgery}^{(2)}_\Pi(S)\big)
$$

and therefore:

$$
\mathrm{SnapshotOnly}(\Pi)
\;\Longrightarrow\;
C_s(S \mid \Pi,\mathcal{O}) \neq 1
\;\;\text{or}\;\;
C_s(S \mid \Pi,\mathcal{O}) = \varnothing
$$

depending on whether the snapshot regime triggers explicit null rules or yields undecidability. In both cases, snapshot cannot license a positive classification as a certification-grade statement, because it cannot execute the kernel’s forgery closure requirements.

---

> **Forgery taxonomy, kernel reference**
>
> **First-order forgery** is signature imitation at the measurement level, where a protocol-defined signature predicate is satisfied while kernel admissibility of the intended target condition is not instantiated.
>
> $$
> \mathrm{Forgery}^{(1)}_\Pi(S,\theta)
> \;:\Longleftrightarrow\;
> \sigma_\Pi(S,\theta)=1 \,\wedge\, \neg \mathrm{Adm}_\Pi(\theta,S)
> \qquad \theta \in \{\Phi_i,R_g\}
> $$
>
> **Second-order forgery** is instrument and evaluation imitation, where passing is contingent on the specific test regime and fails under admissibility-preserving perturbations of the protocol.
>
> $$
> \mathrm{Forgery}^{(2)}_\Pi(S)
> \;:\Longleftrightarrow\;
> \exists \Delta\Pi \in \mathcal{P}_\Pi,\;
> \Big(\mathrm{Pass}(S,\Pi)=1 \,\wedge\, \mathrm{Pass}(S,\Pi+\Delta\Pi)=0\Big)
> $$
>
> Both forgery classes are disqualifying for CIITR positive claims.

### Normative forgery requirements (kernel list)

A CIITR-conformant protocol $\Pi$ SHALL satisfy the following requirements before asserting any non-null comprehension classification.

1. **Explicit forgery model binding:** $\Pi$ SHALL declare forgery as a disqualifier family and SHALL define how forgery indicators are represented in the audit trail.
2. **First-order controls:** $\Pi$ SHALL include at least one negative control family whose sole purpose is to separate signature conformance from kernel instantiation for $\Phi_i$ and for $R_g$.
3. **Second-order controls:** $\Pi$ SHALL include at least one negative control family that varies protocol surface structure within an admissibility-preserving class $\mathcal{P}_\Pi$, and SHALL treat sensitivity to such variation as disqualifying.
4. **No snapshot certification:** if $\Pi$ is snapshot-only, it SHALL NOT issue positive certification claims for $C_s$, since second-order forgery is undecidable under snapshot regimes.
5. **Robustness gating:** $C_s(S \mid \Pi,\mathcal{O})=1$ SHALL be conditional on satisfying $\mathrm{Robust}_\Pi(S)$, meaning forgery controls were executed and did not trigger disqualification.
6. **Audit completeness:** the protocol SHALL preserve metadata sufficient to demonstrate control execution, including protocol versioning, observable declarations, inference rule declarations, and disqualifier evaluation outcomes.

---

© Tor-Ståle Hansen, https://x.com/TSHansen1971  

CC BY-NC-ND 4.0  
Version: 1.0  
Initial publication: 2026-02-09  
Last modified: 2026-02-09
